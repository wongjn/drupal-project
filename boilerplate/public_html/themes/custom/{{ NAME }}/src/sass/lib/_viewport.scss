/**
 * @file
 * Mixins and functions related to the viewport.
 */

@use 'sass:math';
@use 'sass:list';
@use 'sass:string';
@use 'layout';
@use 'unit';

/// Returns the CSS calculation value to scale a length by viewport size.
///
/// @param {Number} $amount
///   Amount to scale, as pixel length but without unit.
/// @param {'vw'|'vh'} $direction ['vw']
///   The viewport dimension to scale with, 'vw' for width or 'vh' for height.
/// @param {Number} $at [layout.$SITE_WIDTH]
///   The viewport dimension length where the scaling should stop at.
/// @param {Number} $from [600]
///   The minimum viewport dimension at which the value will start scaling.
///
/// @return {String}
///   The CSS calculation expression.
@function scaler($amount, $direction: 'vw', $at: layout.$SITE-WIDTH, $from: 600) {
  $divisor: 1 / ($at - $from);
  @return '(#{100 * $divisor * $amount}#{$direction} - #{$from * 1px * $divisor * $amount})';
}

/// Outputs values scaling based on viewport dimensions.
///
/// @param {Length.px|Length.rem|List<Length.px|Length.rem>} $max-values
///   The value(s) at maximum *gate* breakpoint. Works with `px` and `rem`
///   values only.
/// @param {Length.px|Length.rem|List<Length.px|Length.rem} $min-values [0px]
///   The minimum value(s).
/// @param {String|Length.vw|Length.vh} $at [layout.$SITE_WIDTH * 1vw]
///   The breakpoint where the scaling should stop at. Possible values are:
///   - `vmin`: to *gate* when viewport height and width is more than 980px
///   - `Xvw`: to *gate* when viewport width is more than Xpx
///   - `Xvh`: to *gate* when viewport height is more than Xpx
/// @param {Number} $from [600]
///   The minimum breakpoint at which the value should start scaling. The
///   viewport dimension is assumed from $at. This value has no effect if $at is
///   'vmin'.
///
/// @return {Value|List<Value>}
///   Scaling value(s) between minimum and maximum values based on viewport.
@function scale($max-values, $min-values: 0px, $at: layout.$SITE-WIDTH * 1vw, $from: 600) {
  @if ($at != 'vmin' and math.unit($at) != 'vw' and math.unit($at) != 'vh') {
    @error '#{$at} should be a CSS value of vw or vh, with the value being the "maximum gate" breakpoint or literally "vmin".';
  }

  // Ensure $min-values matches length of $max-values.
  @while (list.length($min-values) < list.length($max-values)) {
    $min-values: list.append($min-values, list.nth($min-values, -1));
  }

  $max-values-unitless: ();
  $min-values-unitless: ();
  @for $i from 1 through list.length($max-values) {
    $max: list.nth($max-values, $i);
    $min: list.nth($min-values, $i);

    $max_unit: math.unit($max);
    $min_unit: math.unit($min);

    @if ($max_unit != 'rem' and $max_unit != 'px') {
      @error 'Value #{$i} "#{$max}", must be in px or rem units.';
    }
    @if ($min_unit != 'rem' and $min_unit != 'px') {
      @error 'Min-value #{$i} "#{$min}", must be in px or rem units.';
    }

    $max-values-unitless: list.append($max-values-unitless, unit.strip(
      if($max_unit == 'rem', unit.rem-to-px($max), $max))
    );
    $min-values-unitless: list.append($min-values-unitless, unit.strip(
      if($min_unit == 'rem', unit.rem-to-px($min), $min))
    );
  }

  $values-unitless: list.zip($min-values-unitless, $max-values-unitless);

  $scalers: ();
  @each $min, $max in $values-unitless {
    $scalers: list.append($scalers, if(
      $at == 'vmin',
      '(#{$max - $min} * (100vmin / 980))',
      scaler($max - $min, math.unit($at), unit.strip($at), $from)
    ));
  }

  // Scaling output.
  $values: ();
  @for $i from 1 through list.length($scalers) {
    $max: list.nth($max-values, $i);
    $min: list.nth($min-values, $i);

    $value: $max;

    @if $max != $min {
      $scale: list.nth($scalers, $i);

      $max_unitless: list.nth($max-values-unitless, $i);
      $min_unitless: list.nth($min-values-unitless, $i);

      $lower: if($max_unitless > $min_unitless, $min, $max);
      $scale: string.insert($scale, '#{$min} + ', 1);
      $upper: if($max_unitless > $min_unitless, $max, $min);

      // Older Safari, FF does not support clamp(), use max() and min() instead.
      $value: max(#{$lower}, min(#{$scale}, #{$upper});
    }

    $values: list.append($values, $value);
  }

  @return $values;
}
