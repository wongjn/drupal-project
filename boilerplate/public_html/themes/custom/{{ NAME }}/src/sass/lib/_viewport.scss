/**
 * @file
 * Mixins and functions related to the viewport.
 */

@use 'sass:math';
@use 'sass:list';
@use 'sass:string';
@use 'layout';
@use 'unit';

/// Returns the CSS calculation value to scale a length by viewport size.
///
/// @param {Number} $amount
///   Amount to scale, as pixel length but without unit.
/// @param {'vw'|'vh'} $direction ['vw']
///   The viewport dimension to scale with, 'vw' for width or 'vh' for height.
/// @param {Number} $at [layout.$SITE_WIDTH]
///   The viewport dimension length where the scaling should stop at.
/// @param {Number} $from [600]
///   The minimum viewport dimension at which the value will start scaling.
///
/// @return {String}
///   The CSS calculation expression.
@function scaler($amount, $direction: 'vw', $at: layout.$SITE-WIDTH, $from: 600) {
  $divisor: 1 / ($at - $from);
  @return '(#{100 * $divisor * $amount}#{$direction} - #{$from * 1px * $divisor * $amount})';
}

/// Outputs scaling values.
///
/// @param {String} $property
///   The CSS property to scale a value with, e.g. `margin-right`.
/// @param {Length.px|Length.rem|List<Length.px|Length.rem>} $max-values
///   The value(s) at maximum *gate* breakpoint. Works with `px` and `rem`
///   values only.
/// @param {Length.px|Length.rem|List<Length.px|Length.rem} $min-value [0px]
///   The minimum value(s).
/// @param {String|Length.vw|Length.vh} $at [layout.$SITE_WIDTH * 1vw]
///   The breakpoint where the scaling should stop at. Possible values are:
///   - `vmin`: to *gate* when viewport height and width is more than 980px
///   - `Xvw`: to *gate* when viewport width is more than Xpx
///   - `Xvh`: to *gate* when viewport height is more than Xpx
/// @param {Number} $from [600]
///   The minimum breakpoint at which the value should start scaling. The
///   viewport dimension is assumed from $at. This value has no effect if $at is
///   'vmin'.
///
/// @output
///   Property declaration for scaling value(s) between minimum and maximum
///   values base on viewport.
@mixin scale($property, $max-values, $min-value: 0px, $at: layout.$SITE-WIDTH * 1vw, $from: 600) {
  $deprecated: if(
    typeof($max-values) == number,
    if(math.unit($max-values) == 'vw' or math.unit($max-values) == 'vh', true, false),
    false
  );

  @if $max-values == 'vmin' or $deprecated {
    @warn '$at parameter moved to fourth position';

    // Transpose arguments to correct places from old API.
    $temp: $max-values;
    $max-values: $min-value;
    $min-value: if($at == 'vmin', 0, $at);
    $at: $temp;
  }

  /**
   * FireFox min() max() fallback START
   *
   * @todo: Remove section once Firefox 76 drops.
   */
  @if ($at != 'vmin' and math.unit($at) != 'vw' and math.unit($at) != 'vh') {
    @error '#{$at} should be a CSS value of vw or vh, with the value being the "maximum gate" breakpoint or literally "vmin".';
  }

  // Ensure $min-values matches length of $max-values.
  @while (list.length($min-value) < list.length($max-values)) {
    $min-value: list.append($min-value, list.nth($min-value, -1));
  }

  $media-query-dimension: if(math.unit($at) == 'vw', 'width', 'height');
  $media-query-max: if(
    $at == 'vmin',
    '(orientation: portrait) and (min-width: 980px), (orientation: landscape) and (min-height: 980px)',
    '(min-#{$media-query-dimension}: #{unit.strip($at)}px)'
  );
  $media-query-min: if(
    $at != 'vmin' and $from > 0,
    '(min-#{$media-query-dimension}: #{$from}px)',
    null
  );

  // Scaling output.
  $calcs: ();
  @each $value in scale($max-values, $min-value, $at, $from) {
    $scale_start_index: string.index($value, 'min(') + 4;
    $scale_start: string.slice($value, $scale_start_index);
    $scale_end_index: string.index($scale_start, ',') - 1;
    $calcs: list.append($calcs, calc(#{string.slice($scale_start, 0, $scale_end_index)}));
  }

  @if ($from > 0) {
    #{$property}: $min-value;

    @media #{$media-query-min} {
      #{$property}: $calcs;
    }
  }
  @else {
    #{$property}: $calcs;
  }

  // Gated maximum output
  @media #{$media-query-max} {
    #{$property}: $max-values;
  }

  // === FireFox min() max() fallback END === //
  // #{$property}: scale($max-values, $min-value, $at, $from);
}

/// Outputs values scaling based on viewport dimensions.
///
/// @param {Length.px|Length.rem|List<Length.px|Length.rem>} $max-values
///   The value(s) at maximum *gate* breakpoint. Works with `px` and `rem`
///   values only.
/// @param {Length.px|Length.rem|List<Length.px|Length.rem} $min-values [0px]
///   The minimum value(s).
/// @param {String|Length.vw|Length.vh} $at [layout.$SITE_WIDTH * 1vw]
///   The breakpoint where the scaling should stop at. Possible values are:
///   - `vmin`: to *gate* when viewport height and width is more than 980px
///   - `Xvw`: to *gate* when viewport width is more than Xpx
///   - `Xvh`: to *gate* when viewport height is more than Xpx
/// @param {Number} $from [600]
///   The minimum breakpoint at which the value should start scaling. The
///   viewport dimension is assumed from $at. This value has no effect if $at is
///   'vmin'.
///
/// @return {Value|List<Value>}
///   Scaling value(s) between minimum and maximum values based on viewport.
@function scale($max-values, $min-values: 0px, $at: layout.$SITE-WIDTH * 1vw, $from: 600) {
  @if ($at != 'vmin' and math.unit($at) != 'vw' and math.unit($at) != 'vh') {
    @error '#{$at} should be a CSS value of vw or vh, with the value being the "maximum gate" breakpoint or literally "vmin".';
  }

  // Ensure $min-values matches length of $max-values.
  @while (list.length($min-values) < list.length($max-values)) {
    $min-values: list.append($min-values, list.nth($min-values, -1));
  }

  $max-values-unitless: ();
  $min-values-unitless: ();
  @for $i from 1 through list.length($max-values) {
    $max: list.nth($max-values, $i);
    $min: list.nth($min-values, $i);

    $max-values-unitless: list.append($max-values-unitless, unit.strip(
      if(math.unit($max) == 'rem', unit.rem-to-px($max), $max))
    );
    $min-values-unitless: list.append($min-values-unitless, unit.strip(
      if(math.unit($min) == 'rem', unit.rem-to-px($min), $min))
    );
  }

  $values-unitless: list.zip($min-values-unitless, $max-values-unitless);

  $scalers: ();
  @each $min, $max in $values-unitless {
    $scalers: list.append($scalers, if(
      $at == 'vmin',
      '(#{$max - $min} * (100vmin / 980))',
      scaler($max - $min, math.unit($at), unit.strip($at), $from)
    ));
  }

  // Scaling output.
  $values: ();
  @for $i from 1 through list.length($scalers) {
    $max: list.nth($max-values, $i);
    $min: list.nth($min-values, $i);

    $scale: list.nth($scalers, $i);
    @if ($min > 0) {
      $scale: string.insert($scale, '#{$min} + ', 1);
    }

    // Using clamp() would be more readable here, but no support in Safari.
    $values: list.append($values, max(#{$min}, min(#{$scale}, #{$max})));
  }

  @return $values;
}
